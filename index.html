<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Color Picker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
</head>
<body style="margin:0; padding:0;">
<input type="file" id="fileInput" accept="image/*" 
       style="display:block; margin:10px auto; position:relative; z-index:10;" />

<script>
let img;
let imgWidth, imgHeight;
let uploadedFile;

let xWhite, yWhite;
let xColor, yColor;

let runWhite = false;
let whitePrompt = false;
let whiteDirections = false;
let whitePicked = false;

let runColor = false;
let colorPrompt = false;
let colorDirections = false;
let colorPicked = false;
let finishedPicking = false;

let createButtons = false;

let d;

// button geometry
let btnConfirm = { x: 20, y: 0, w: 120, h: 44 };
let btnReset   = { x: 160, y: 0, w: 120, h: 44 };

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);
  textSize(20);
  textWrap(WORD);
  d = new DetectColor();

  const fileInput = document.getElementById('fileInput');
  fileInput.addEventListener('change', (event) => {
    uploadedFile = event.target.files[0];
    if (uploadedFile) {
      if (!uploadedFile.type.startsWith("image/")) {
        alert("Please upload a valid image file (JPG, PNG, etc.)");
        return;
      }
      const objectURL = URL.createObjectURL(uploadedFile);
      loadImage(objectURL, (loadedImg) => {
        img = loadedImg;
        URL.revokeObjectURL(objectURL);
        const maxW = width * 0.9;
        const maxH = height * 0.6;
        if (img.width > maxW || img.height > maxH) {
          const scale = min(maxW / img.width, maxH / img.height);
          imgWidth = img.width * scale;
          imgHeight = img.height * scale;
        } else {
          imgWidth = img.width;
          imgHeight = img.height;
        }
        runWhite = true;
        whitePrompt = true;
      });
    }
  });
}

function draw() {
  background(255);

  if (!img) {
    fill(0);
    textSize(22);
    text("Upload an image to start", width * 0.05, 20, width * 0.9);
    return;
  }

  const imgX = (width - imgWidth) / 2;
  const imgY = (height - imgHeight) / 2;
  image(img, imgX, imgY, imgWidth, imgHeight);

  window.imgBounds = { x: imgX, y: imgY, w: imgWidth, h: imgHeight };

  fill(0);
  textSize(22);

  if (whitePrompt) {
    fill('red');
    text("Tap on the white circle", width * 0.05, 20, width * 0.9);
  }

  if (whiteDirections) {
    fill('red');
    ellipse(xWhite, yWhite, 7);
    fill(0);
    textSize(18);
    textLeading(24);

    // instructions ABOVE the picture
    const instructions =
      "This is where the white color will be recorded\n" +
      "Press CONFIRM to confirm, RESET to choose a different spot for white color";
    const textTop = max(20, imgY - 80); 
    text(instructions, width * 0.05, textTop, width * 0.9);

    // buttons BELOW the picture
    const buttonY = imgY + imgHeight + 30;
    drawButtons(buttonY);

    createButtons = true;
  }

  if (colorPrompt) {
    fill('red');
    text("Tap on the purple circle", width * 0.05, 20, width * 0.9);
    fill(0);
    ellipse(xWhite, yWhite, 7);
  }

  if (colorDirections) {
    fill(0);
    ellipse(xWhite, yWhite, 7);
    fill('red');
    ellipse(xColor, yColor, 7);
    fill(0);
    textSize(18);
    textLeading(24);

    // instructions ABOVE the picture
    const instructions =
      "This is where the purple color will be recorded\n" +
      "Press CONFIRM to confirm, RESET to choose a different spot for purple color";
    const textTop = max(20, imgY - 80); 
    text(instructions, width * 0.05, textTop, width * 0.9);

    // buttons BELOW the picture
    const buttonY = imgY + imgHeight + 30;
    drawButtons(buttonY);

    createButtons = true;
  }

  if (finishedPicking) {
    let c = d.colors();
    background(c[0], c[1], c[2]);
    fill(c[3], c[4], c[5]);
    let s = d.getColorValues();
    textSize(20);
    text(`Red: ${s[0]}, Green: ${s[1]}, Blue: ${s[2]}`, width * 0.05, 20, width * 0.9);
    textSize(24);
    text("Adjusted values:", width * 0.05, 60, width * 0.9);
    text(`Red: ${s[3]}, Green: ${s[4]}, Blue: ${s[5]}`, width * 0.05, 96, width * 0.9);
    text("CF diagnosis: will add once data is collected", width * 0.05, 132, width * 0.9);
  }
}

function touchStarted() {
  if (touches.length > 0) {
    handleInput(touches[0].x, touches[0].y);
  }
}

function mousePressed() {
  handleInput(mouseX, mouseY);
}

function handleInput(mx, my) {
  if (!window.imgBounds) return;

  const insideImage = img &&
    mx >= window.imgBounds.x && mx <= window.imgBounds.x + window.imgBounds.w &&
    my >= window.imgBounds.y && my <= window.imgBounds.y + window.imgBounds.h;

  if (runWhite && whitePrompt && insideImage) {
    xWhite = mx; yWhite = my;
    whitePrompt = false; whiteDirections = true; whitePicked = true;
    const px = floor((mx - window.imgBounds.x) * (img.width / window.imgBounds.w));
    const py = floor((my - window.imgBounds.y) * (img.height / window.imgBounds.h));
    d.whiteCircle(px, py, img);
    return;
  }

  if (runColor && colorPrompt && insideImage) {
    xColor = mx; yColor = my;
    colorPrompt = false; colorDirections = true; colorPicked = true;
    const px = floor((mx - window.imgBounds.x) * (img.width / window.imgBounds.w));
    const py = floor((my - window.imgBounds.y) * (img.height / window.imgBounds.h));
    d.purple(px, py, img);
    return;
  }

  if (whiteDirections) {
    if (pointInRect(mx, my, btnConfirm)) {
      runWhite = false; runColor = true;
      colorPrompt = true; createButtons = false; whiteDirections = false;
      return;
    }
    if (pointInRect(mx, my, btnReset)) {
      whitePicked = false; whitePrompt = true;
      whiteDirections = false; createButtons = false;
      return;
    }
  }

  if (colorDirections) {
    if (pointInRect(mx, my, btnConfirm)) {
      finishedPicking = true; runColor = false;
      colorDirections = false; createButtons = false;
      return;
    }
    if (pointInRect(mx, my, btnReset)) {
      colorPicked = false; colorPrompt = true;
      colorDirections = false; createButtons = false;
      return;
    }
  }
}

function pointInRect(px, py, r) {
  return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
}

function drawButtons(y) {
  const btnW = min(150, width * 0.4);
  const btnH = 44;
  const gap = min(20, width * 0.05);
  const startX = 20;

  btnConfirm.x = startX;
  btnConfirm.y = y;
  btnConfirm.w = btnW;
  btnConfirm.h = btnH;

  btnReset.x = startX + btnW + gap;
  btnReset.y = y;
  btnReset.w = btnW;
  btnReset.h = btnH;

  push();
  stroke(60);
  fill(220);
  rect(btnConfirm.x, btnConfirm.y, btnConfirm.w, btnConfirm.h, 10);
  rect(btnReset.x, btnReset.y, btnReset.w, btnReset.h, 10);

  noStroke();
  fill(0);
  textSize(16);
  textAlign(CENTER, CENTER);
  text("CONFIRM", btnConfirm.x + btnConfirm.w/2, btnConfirm.y + btnConfirm.h/2);
  text("RESET",   btnReset.x   + btnReset.w/2,   btnReset.y   + btnReset.h/2);
  pop();
}

class DetectColor {
  constructor() {
    this.whiter = 0; this.whiteg = 0; this.whiteb = 0;
    this.scaleR = 1; this.scaleG = 1; this.scaleB = 1;
    this.correctedR = 0; this.correctedG = 0; this.correctedB = 0;
    this.r = 0; this.g = 0; this.b = 0; this.s = [];
  }

  whiteCircle(x, y, imageRef) {
    const c = imageRef.get(x, y);
    this.whiter = red(c); this.whiteg = green(c); this.whiteb = blue(c);
  }

  purple(x, y, imageRef) {
    const c = imageRef.get(x, y);
    this.r = red(c); this.g = green(c); this.b = blue(c);
    this.scaleR = 255 / this.whiter;
    this.scaleG = 255 / this.whiteg;
    this.scaleB = 255 / this.whiteb;
    this.correctedR = constrain(this.r * this.scaleR, 0, 255);
    this.correctedG = constrain(this.g * this.scaleG, 0, 255);
    this.correctedB = constrain(this.b * this.scaleB, 0, 255);
  }

  getColorValues() {
    if (this.s.length < 6) {
      this.s.push(
        int(this.r), int(this.g), int(this.b),
        int(this.correctedR), int(this.correctedG), int(this.correctedB)
      );
    }
    return this.s;
  }

  colors() {
    return [
      int(this.whiter * this.scaleR),
      int(this.whiteg * this.scaleG),
      int(this.whiteb * this.scaleB),
      int(this.correctedR),
      int(this.correctedG),
      int(this.correctedB)
    ];
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
