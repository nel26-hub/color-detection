<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Color Picker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
</head>
<body style="margin:0; padding:0;">
<input type="file" id="fileInput" accept="image/*" style="display:block; margin:10px auto;" />
<script>
let img;
let imgWidth, imgHeight;
let uploadedFile;

let xWhite, yWhite;
let xColor, yColor;

let runWhite = false;
let whitePrompt = false;
let whiteDirections = false;
let whitePicked = false;

let runColor = false;
let colorPrompt = false;
let colorDirections = false;
let colorPicked = false;
let finishedPicking = false;

let createButtons = false;

let d;

// button geometry shared by draw + hit test
let btnConfirm = { x: 20, y: 0, w: 120, h: 44 };
let btnReset   = { x: 160, y: 0, w: 120, h: 44 };

function setup() {
  createCanvas(windowWidth, windowHeight);
  background(255);
  textSize(20);
  textWrap(WORD);
  d = new DetectColor();

  const fileInput = document.getElementById('fileInput');
  fileInput.addEventListener('change', (event) => {
    uploadedFile = event.target.files[0];
    if (uploadedFile) {
      loadImage(URL.createObjectURL(uploadedFile), (loadedImg) => {
        img = loadedImg;
        const maxW = width * 0.9;
        const maxH = height * 0.6;
        if (img.width > maxW || img.height > maxH) {
          const scale = min(maxW / img.width, maxH / img.height);
          imgWidth = img.width * scale;
          imgHeight = img.height * scale;
        } else {
          imgWidth = img.width;
          imgHeight = img.height;
        }
        runWhite = true;
        whitePrompt = true;
      });
    }
  });
}

function draw() {
  background(255);

  // leave space for instructions above image
  const imgX = width * 0.05;
  const imgY = height * 0.25;

  if (img) image(img, imgX, imgY, imgWidth, imgHeight);

  fill(0);
  textSize(22);

  if (!img) {
    text("Upload an image to start", width * 0.05, 20, width * 0.9);
    return;
  }

  if (whitePrompt) {
    fill('red');
    text("Tap on the white circle", width * 0.05, 20, width * 0.9);
  }

  if (whiteDirections) {
    fill('red');
    ellipse(xWhite, yWhite, 7);
    fill(0);
    text("This is where the white color will be recorded", width * 0.05, 20, width * 0.9);
    text("Press CONFIRM to confirm, RESET to choose a different spot for white color", width * 0.05, 60, width * 0.9);
    createButtons = true;
  }

  if (colorPrompt) {
    fill('red');
    text("Tap on the purple circle", width * 0.05, 20, width * 0.9);
    fill(0);
    ellipse(xWhite, yWhite, 7);
  }

  if (colorDirections) {
    fill(0);
    ellipse(xWhite, yWhite, 7);
    fill('red');
    ellipse(xColor, yColor, 7);
    fill(0);
    text("This is where the purple color will be recorded", width * 0.05, 20, width * 0.9);
    text("Press CONFIRM to confirm, RESET to choose a different spot for purple color", width * 0.05, 60, width * 0.9);
    createButtons = true;
  }

  if (finishedPicking) {
    let c = d.colors();
    background(c[0], c[2], c[1]);
    fill(c[3], c[5], c[4]);
    let s = d.getColorValues();
    textSize(20);
    text(`Red: ${s[0]}, Blue: ${s[1]}, Green: ${s[2]}`, width * 0.05, 20, width * 0.9);
    textSize(24);
    text("Adjusted values:", width * 0.05, 60, width * 0.9);
    text(`Red: ${s[3]}, Blue: ${s[4]}, Green: ${s[5]}`, width * 0.05, 96, width * 0.9);
    text("CF diagnosis: will add once data is collected", width * 0.05, 132, width * 0.9);
  }

  if (createButtons) drawButtons();
}

function touchStarted() {
  handleInput(touchX, touchY);
  return false;
}

function mousePressed() {
  handleInput(mouseX, mouseY);
}

function handleInput(mx, my) {
  // image bounds for hit testing
  const imgX = width * 0.05;
  const imgY = height * 0.25;
  const insideImage = img &&
    mx >= imgX && mx <= imgX + imgWidth &&
    my >= imgY && my <= imgY + imgHeight;

  // White selection
  if (runWhite && whitePrompt && insideImage) {
    xWhite = mx;
    yWhite = my;
    whitePrompt = false;
    whiteDirections = true;
    whitePicked = true;
    const px = floor((mx - imgX) * (img.width / imgWidth));
    const py = floor((my - imgY) * (img.height / imgHeight));
    d.whiteCircle(px, py, img);
    return;
  }

  // Purple selection
  if (runColor && colorPrompt && insideImage) {
    xColor = mx;
    yColor = my;
    colorPrompt = false;
    colorDirections = true;
    colorPicked = true;
    const px = floor((mx - imgX) * (img.width / imgWidth));
    const py = floor((my - imgY) * (img.height / imgHeight));
    d.purple(px, py, img);
    return;
  }

  // Button hits (use same geometry as drawButtons)
  if (whiteDirections) {
    if (pointInRect(mx, my, btnConfirm)) {
      runWhite = false;
      runColor = true;
      colorPrompt = true;
      createButtons = false;
      whiteDirections = false;
      return;
    }
    if (pointInRect(mx, my, btnReset)) {
      whitePicked = false;
      whitePrompt = true;
      whiteDirections = false;
      createButtons = false;
      return;
    }
  }

  if (colorDirections) {
    if (pointInRect(mx, my, btnConfirm)) {
      finishedPicking = true;
      runColor = false;
      colorDirections = false;
      createButtons = false;
      return;
    }
    if (pointInRect(mx, my, btnReset)) {
      colorPicked = false;
      colorPrompt = true;
      colorDirections = false;
      createButtons = false;
      return;
    }
  }
}

function pointInRect(px, py, r) {
  return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
}

function drawButtons() {
  // place buttons a bit below the instruction text, responsive width
  const buttonY = height * 0.16;
  const btnW = min(150, width * 0.4);
  const btnH = 44;
  const gap = min(20, width * 0.05);
  const startX = 20;

  // update shared geometry
  btnConfirm.x = startX;
  btnConfirm.y = buttonY;
  btnConfirm.w = btnW;
  btnConfirm.h = btnH;

  btnReset.x = startX + btnW + gap;
  btnReset.y = buttonY;
  btnReset.w = btnW;
  btnReset.h = btnH;

  push();
  stroke(60);
  fill(220);
  rect(btnConfirm.x, btnConfirm.y, btnConfirm.w, btnConfirm.h, 10);
  rect(btnReset.x, btnReset.y, btnReset.w, btnReset.h, 10);

  noStroke();
  fill(0);
  textSize(16);
  textAlign(CENTER, CENTER);  // <-- centers labels inside each rect
  text("CONFIRM", btnConfirm.x + btnConfirm.w/2, btnConfirm.y + btnConfirm.h/2);
  text("RESET",   btnReset.x   + btnReset.w/2,   btnReset.y   + btnReset.h/2);
  pop();
}

class DetectColor {
  constructor() {
    this.whiter = 0; this.whiteb = 0; this.whiteg = 0;
    this.scaleR = 1; this.scaleB = 1; this.scaleG = 1;
    this.correctedR = 0; this.correctedB = 0; this.correctedG = 0;
    this.r = 0; this.b = 0; this.g = 0; this.s = [];
  }

  whiteCircle(x, y, imageRef) {
    const c = imageRef.get(x, y);
    this.whiter = red(c); this.whiteb = blue(c); this.whiteg = green(c);
  }

  purple(x, y, imageRef) {
    const c = imageRef.get(x, y);
    this.r = red(c); this.b = blue(c); this.g = green(c);
    this.scaleR = 255 / this.whiter;
    this.scaleB = 255 / this.whiteb;
    this.scaleG = 255 / this.whiteg;
    this.correctedR = constrain(this.r * this.scaleR, 0, 255);
    this.correctedB = constrain(this.b * this.scaleB, 0, 255);
    this.correctedG = constrain(this.g * this.scaleG, 0, 255);
  }

  getColorValues() {
    if (this.s.length < 6) {
      this.s.push(
        int(this.r), int(this.b), int(this.g),
        int(this.correctedR), int(this.correctedB), int(this.correctedG)
      );
    }
    return this.s;
  }

  colors() {
    return [
      int(this.whiter * this.scaleR),
      int(this.whiteb * this.scaleB),
      int(this.whiteg * this.scaleG),
      int(this.correctedR),
      int(this.correctedB),
      int(this.correctedG)
    ];
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
