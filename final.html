<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Color Picker</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
</head>
<body>
<script>
let newImage;
let d;
let xWhite = 0, yWhite = 0;
let xColor = 0, yColor = 0;

let whitePicked = false;
let whiteConfirmed = false;
let colorPicked = false;
let colorConfirmed = false;
let finishedPicking = false;

let canvasWidth, canvasHeight;
let instructionHeight = 100; // space at top for instructions
let imageOffset = instructionHeight + 20; // move image down slightly

let fileInput;

function setup() {
  canvasWidth = min(windowWidth, 800);
  canvasHeight = min(windowHeight, 800);
  createCanvas(canvasWidth, canvasHeight);
  background(255);

  d = new DetectColor();

  fileInput = createFileInput(handleFile);
  fileInput.position(20, 20); // initial position
}

function draw() {
  background(255);

  // Draw instructions at top
  fill(0);
  textSize(20);
  let instrY = 40;

  if (!newImage) {
    text("Select an image file to begin", 20, instrY+40);
    return;
  }

  if (whitePicked && !whiteConfirmed) {
    text("This is where the white will be recorded.", 20, instrY);
    text("Press ENTER if this is correct.", 20, instrY + 30);
    text("Press DELETE if this is incorrect.", 20, instrY + 60);
  } else if (!whitePicked && !whiteConfirmed) {
    text("Click on white circle", 20, instrY);
  }

  if (whiteConfirmed) {
    if (colorPicked && !colorConfirmed) {
      text("This is where the color will be recorded.", 20, instrY);
      text("Press ENTER if this is correct.", 20, instrY + 30);
      text("Press DELETE if this is incorrect.", 20, instrY + 60);
    } else if (!colorPicked) {
      text("Click on color", 20, instrY);
    }
  }

  // Draw image below instructions
  image(newImage, 0, imageOffset);

  let adjustedYWhite = yWhite + imageOffset;
  let adjustedYColor = yColor + imageOffset;

  // White circle
  if (whitePicked && !whiteConfirmed) {
    fill(255, 0, 0);
    noStroke();
    circle(xWhite, adjustedYWhite, 10);
    fill(0);
    circle(xWhite, adjustedYWhite, 5);
  }
  if (whiteConfirmed) {
    fill(0);
    noStroke();
    circle(xWhite, adjustedYWhite, 10);
  }

  // Color circle
  if (colorPicked && !colorConfirmed) {
    fill(255, 0, 0);
    noStroke();
    circle(xColor, adjustedYColor, 10);
  }
  if (colorConfirmed) {
    fill(255, 0, 0);
    noStroke();
    circle(xColor, adjustedYColor, 10);
  }

  // Final colors
  if (finishedPicking) {
    let c = d.colors();
    background(c[0], c[1], c[2]);
    fill(c[3], c[4], c[5]);
    let s = d.getColorValues();
    textSize(20);
    fill(0);
    text(`Original colors - R:${s[0]}, G:${s[1]}, B:${s[2]}`, 20, 100);
    textSize(30);
    text("Adjusted colors:", 20, 150);
    text(`R:${s[3]}, G:${s[4]}, B:${s[5]}`, 20, 200);
  }
}

function mousePressed() {
  if (!newImage) return;

  let mx = constrain(mouseX, 0, newImage.width - 1);
  let my = constrain(mouseY - imageOffset, 0, newImage.height - 1); // adjust for image offset

  if (!whiteConfirmed && !whitePicked) {
    xWhite = mx;
    yWhite = my;
    d.whiteCircle(xWhite, yWhite);
    whitePicked = true;
  } else if (whiteConfirmed && !colorConfirmed && !colorPicked) {
    xColor = mx;
    yColor = my;
    d.purple(xColor, yColor);
    colorPicked = true;
  }
}

function keyPressed() {
  if (keyCode === ENTER) {
    if (whitePicked && !whiteConfirmed) {
      whiteConfirmed = true;
      colorPicked = false;
    } else if (colorPicked && !colorConfirmed) {
      colorConfirmed = true;
      finishedPicking = true;
    }
  }

  if (keyCode === DELETE || keyCode === BACKSPACE) {
    if (whitePicked && !whiteConfirmed) whitePicked = false;
    else if (colorPicked && !colorConfirmed) colorPicked = false;
  }
}

function handleFile(file) {
  if (file.type === 'image') {
    loadImage(file.data, img => {
      // Resize image to fit canvas while keeping aspect ratio
      let maxDim = min(windowWidth, windowHeight, 800) - imageOffset;
      let scaleFactor = 1;

      if (img.width > maxDim || img.height > maxDim) {
        if (img.width > img.height) {
          scaleFactor = maxDim / img.width;
        } else {
          scaleFactor = maxDim / img.height;
        }
      }

      img.resize(floor(img.width * scaleFactor), floor(img.height * scaleFactor));
      newImage = img;

      // Resize canvas to fit image + offset
      resizeCanvas(newImage.width, newImage.height + imageOffset);

      // Hide file input after image is loaded
      fileInput.hide();

      // Reset variables
      whitePicked = false;
      whiteConfirmed = false;
      colorPicked = false;
      colorConfirmed = false;
      finishedPicking = false;
    });
  } else {
    alert("Please upload a valid image file (png, jpg, jpeg).");
  }
}

// -------- DetectColor class --------
class DetectColor {
  constructor() {
    this.whiter = 0;
    this.whiteg = 0;
    this.whiteb = 0;
    this.scaleR = 0;
    this.scaleG = 0;
    this.scaleB = 0;
    this.correctedR = 0;
    this.correctedG = 0;
    this.correctedB = 0;
    this.r = 0;
    this.g = 0;
    this.b = 0;
  }

  whiteCircle(px, py) {
    newImage.loadPixels();
    let index = (py * newImage.width + px) * 4;
    this.whiter = newImage.pixels[index];
    this.whiteg = newImage.pixels[index + 1];
    this.whiteb = newImage.pixels[index + 2];
  }

  purple(px, py) {
    newImage.loadPixels();
    let index = (py * newImage.width + px) * 4;
    this.r = newImage.pixels[index];
    this.g = newImage.pixels[index + 1];
    this.b = newImage.pixels[index + 2];

    this.scaleR = this.whiter ? 255 / this.whiter : 1;
    this.scaleG = this.whiteg ? 255 / this.whiteg : 1;
    this.scaleB = this.whiteb ? 255 / this.whiteb : 1;

    this.correctedR = constrain(this.r * this.scaleR, 0, 255);
    this.correctedG = constrain(this.g * this.scaleG, 0, 255);
    this.correctedB = constrain(this.b * this.scaleB, 0, 255);
  }

  getColorValues() {
    return [
      int(this.r),
      int(this.g),
      int(this.b),
      int(this.correctedR),
      int(this.correctedG),
      int(this.correctedB)
    ];
  }

  colors() {
    return [
      int(this.whiter * this.scaleR),
      int(this.whiteg * this.scaleG),
      int(this.whiteb * this.scaleB),
      int(this.correctedR),
      int(this.correctedG),
      int(this.correctedB)
    ];
  }
}
</script>
</body>
</html>
